#summary Explaining the design of the ES operating system's TCP/IP stack.
#labels TCPIP,stack,conduit

= Designing the ES operating system's TCP/IP stack =

== Introduction ==

ES's TCP/IP stack is essentially based on the Conduit+ framework laid out in `[`Hüni 95`]`. One of the authors of `[`Hüni 95`]`, professor R. E. Johnson, was also one of the "Design Patterns" GoF.

In the 1980s, protocol stack implementation was an extremely difficult problem. In his foreword to `[`Comer 87`]`, professor David D. Clark stated that, with regards to implementing the stack according to the OSI 7 layer reference model: "The layering suggested by the specification must be violated to insure efficient execution. ... The implementor must go it alone, trying to blend together network abstraction and operating system abstraction which don't seem to fit well." However, we know that tools for structurally designing and implementing an operating system-level protocol stack such as a stream input-output system `[`Ritchie 84`]` and a multiplexer `[`Pike 84`]` were proposed from around that time. Hüni et al.'s Conduit+ framework is the application of design patterns on these proposals. In the Conduit+ framework, the modules and multiplexers layered on the stack composed of streams are known as "conduits". Depending on how they are used, conduits are split into four groups: protocol, adapter, mux and factory. The aim of the Conduit+ framework is to make the network stack structure easier to learn and use by applying the Strategy, State, Singleton, Command, Visitor and Prototype patterns to these conduits.

However, as far as the authors are aware, there are so far no examples of a complete TCP/IP stack being built with the Conduit+ framework. Nikander et al. used Java to implement UDP/IP with the Conduit+ framework but as a student project could not find the time to complete the implementation to include TCP/IP `[`Nikander 98`]`.

According to Wright et al.'s excellent paper `[`Wright 95`]`, it seems that just reading the code of 4.4BSD-Lite's TCP/IP stack written in C would lead you to believe that it was not that complicated, but even so, updating it or experimenting with it surely remains extremely difficult. With the ES operating system, we're aiming to implement and openly provide a TCP/IP stack following the RFC 1122 standard and based on the Conduit+ framework.

== TCP/IP stack conduit graph ==

Below is a conduit graph showing ES's IPv4 stack based on the Conduit+ framework. (We have used ellipses whereas ellipses and rectangles are used in `[`Hüni 95`]`.)

http://es-operating-system.googlecode.com/svn/html/Conduit/inet4.png

The conduit graph has been greatly simplified but we can see how this can be scaled to cover the entire TCP/IP stack. In the conduit graph, packets and data received by the adapter from applications and the network are stored in command-carrying messengers and transmitted by visitors. The visitors issue commands to the conduits of these adapters and protocols. The commands issued by the visitors are processed by receivers corresponding to these conduits. In the receiver class, the State pattern is used and processes run depending on the state of the TCP, ARP and IGMP protocols. In IPv6, ARP and IGMP have been integrated into ICMPv6 so we'll touch briefly on how the conduit graph is even simpler than for IPv4 (implementation of IPv6 is already underway in ES).

== Ethernet drivers ==

At present, the ES operating system supports LAN cards with Realtek's NE2000-compatible RTL8029AS ethernet controller chip. RTL8029AS is an extremely popular controller that can also be emulated in QEMU. RTL8029AS can also be found on Buffalo's LGY-PCI-TL LAN card.

There are many modern ethernet controllers that can handle processes on the controller-side that are currently done in the CPU, but processes that ethernet drivers support are basically as follows:

  * Sending packets.
  * Receiving packets.
  * Getting MAC addresses allocated by the controller.
  * Adding/removing multicast addresses that want to send packets.
  * Getting link status (whether a port can connect to a switch, hub, etc.).
  * Setting/removing promiscuous mode (unfiltered reception mode).

In the ES operating system, these tasks are defined as the INetworkInterface. In ES you can use ethernet controller chips other than RTL8029AS just by implementing the INetworkInterface.

Please refer to dp8390d.cpp

== DIX conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/dix.png

Depending on the packet type of the ethernet packet (frame) headers it receives, dixTypeMux sends out packets to dixInProtocol (IPv4) and dixArpProtocol (ARP). dixInProtocol and dixArpProtocol add the appropriate ethernet packet headers to the packets being sent.

== ARP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/arp.png

At the ethernet level, packets are transmitted with a MAC address specified. Resolving the connection between IP addresses used in TCP/IP and ethernet MAC addresses is the role of the ARP protocol. The basic configuration of ARP is that an enquiry is broadcast as to whether the nodes assigned to the IP addresses trying to communicate exist or not and the recipient of the enquiry who has the IP address of a requested node then sends its own MAC address to the original sender. Requesting a MAC address with ARP every time a packet is sent makes for an inefficient network, so with ARP conduits a node temporarily caches MAC addresses and IP addresses that it has enquired about.

Another feature of ARP is that it obtains link-local IP addresses. Link-local IP addresses are addresses that are assigned dynamically on a LAN without a DHCP server and can handle TCP/IP communication between information appliances on a home LAN not connected to a router without special configuration. In obtaining link-local IP addresses, an appliance on the LAN broadcasts an enquiry as to whether the link-local IP address it wants to use is already in use or not (i.e. not responding) and if no reply is received, the IP address is assigned to that appliance.

=== Status of onlink's Inet4Address object ===

ArpProtocol looks for the source protocol address of the ARP packet received and, if the Inet4Address object for that address is already cached, changes its status to reachable. ArpMux sends received ARP packets corresponding to their target protocol addresses to ArpAdapter. ArpAdapter receivers run status-related processes with the Inet4Address object.

http://es-operating-system.googlecode.com/svn/html/Conduit/arp_std.png

|| Status || Description || RFC ||
|| Init || The MAC address corresponding to the IP address is not yet known. || 826 ||
|| Incomplete || The MAC address corresponding to the IP address is being requested. || 826 ||
|| Reachable || The MAC address corresponding to the IP address is known. || 826 ||
|| Probe || The MAC address corresponding to the IP address is being re-checked. || 826 ||
|| Tentative || Checking whether a local address can be used. || 3927 ||
|| Preferred || A local address can be used. || 3927 ||
|| Deprecated || A local address that is due to be discontinued. || 3927 ||

N.B. In the Inet4Address object there are other states relating to multicast addresses and destination addresses which we will cover later.

Please refer to arp.cpp, RFC 826 and RFC 3927.

== IP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/ip.png

InProtocol looks for the protocol number of received IP packets and sends the packets to InMux. If the received IP packets are fragmented packets, IPPROTO_FRAGMENT is configured as a pseudo-protocol number so that they can be processed by the higher fragment reassembly conduit. (IPPROTO_FRAGMENT is originally a protocol number for IPv6.) In the case that the destination of IP packets being sent by InProtocol is not the loopback address or the on-link IP address, the messenger is configured to send messages to the router. It also gets the packet length and if it is larger than the path MTU, fragments it and sends it on to the lower InScopeMux.

InMux gets the protocol number of the received IP packet and sends it to the higher conduit with UDP, TCP, etc.

InScopeMux gets the scope ID of the packet to be sent and divides the packet between the even lower loopback interface and ethernet interface.

Please refer to inet4.cpp and RFC 791.

== ICMP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/icmp.png

The ICMP conduit handles ICMP error mesages and ICMP echo messages.

IcmpMux looks at the TYPE field of received ICMP messages and sends the messages to conduits based on their TYPE.

EchoRequestMux processes received ICMP echo requests (8). The EchoRequestAdapter forked by EchoRequestMux is installed in each local address when the Inet4Address object's status is Preferred. The EchoRequestAdapter returns ICMP echo replies.

EchoReplyMux processes received ICMP echo replies (0). The EchoReplyAdapter forked from EchoReplyMux is installed when the Inet4Address object's isReachable method is called. When the EchoReplyAdapter receives the ICMP echo reply, the isReachable method finishes.

UnreachProtocol, TimeExceededProtocol, etc. handle ICMP error messages. When ICMP error messages are received, a copy of the header of the IP packet that caused the problem contained in the error message is used as the base of the message re-sent as an error message to InProtocol if necessary. This time, the error message is sent to the conduit that originally sent the packet (TCP, etc.) and not the ICMP conduit.

Please refer to icmp4.cpp and RFC 792.

== Fragment reassembly conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/reass.png

Fragmented packets are all sent to the fragment reassembly conduit from InMux. ReassAdapter is installed when the fragments of new IP packet numbers arrive at the node. When the fragment reassembly by ReassAdapter is complete, the reassembled packets are sent from InProtocol to the higher conduit. ReassAdapter is uninstalled either when fragment reassembly is complete or when reassembly fails due to a timeout.

N.B.: In the IPv4 RFC, fragment reassembly is done at the IP layer but it was easier to implement this at a higher layer similar to IPv6 where it is regarded as a single, independent protocol process. This point was pointed out by professor Clark, but is also a result of IPv6 protocol configuration itself becoming more refined.

Please refer to inet4reass.cpp and RFC 815.

== UDP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/udp.png

The UDP conduit processes UDP datagrams. UDP-related processes peculiar to IPv4 are handled in the lower UdpProtocol. Meanwhile, UDP-related processes common to IPv4 and IPv6 are handled in the upper DatagramProtocol.

Please refer to datagram.cpp, udp.cpp and RFC 793.

== TCP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/XV_Semana_Informatica/tcp.png

TCP processes are handled by the TCP conduit. TCP-related processes peculiar to IPv4 are handled in the lower TcpProtocol. Meanwhile, TCP-related processes common to IPv4 and IPv6 are handled in the upper StreamProtocol. StreamProtocol deals with TCP processes using the State pattern.

Please refer to stream.cpp, tcp.cpp and RFC 768.

== IGMP conduit ==

http://es-operating-system.googlecode.com/svn/html/Conduit/igmp.png

=== Inet4Address object multicast address status ===

When you make an address object specifying a multicast address using the IResolver interface, an Inet4Address object with NonMember status is created. To join a multicast group, the IMulticastSocket interface's joinGroup method is called with the multicast address's Inet4Address object as an argument. In doing this, a new igmpAdapter is installed in the IGMP conduit and the Inet4Address object sends an IGMP REPORT message and then changes status to DelayingMember. Usually an Inet4Address object with DelayingMember status stops with a timeout, sends another IGMP REPORT message and changes to IdleMember status. To leave a multicast group, the IMulticastSocket interface's leaveGroup method is called. In doing this, the Inet4Address object sends an IGMP LEAVE message, changes status to IdleMember and then igmpAdapter is uninstalled from the IGMP conduit.

There are cases when a multicast router will send an IGMP QUERY message to check whether there is a node that has joined a multicast group in the LAN. When the QUERY is received, the Inet4Address object's status changes to DelayingMember. Basically, QUERY needs to be replied to with REPORT but the router only needs to know whether there is a single node that has joined a group in the LAN so it is a waste of traffic if all nodes reply to QUERY. Because of this, in RFC 2236 a node belonging to a group that receives QUERY does not send REPORT immediately, but rather goes on standby for a certain length of time and if another node sends REPORT in that time, it then changes status to IdleMember without sending anything itself. Alternatively, if it can't confirm that REPORT has been sent while on standby, it will send REPORT itself and then change status to IdleMember. Standby time is decided randomly per node so in most cases any single node will send REPORT in response to QUERY.

http://es-operating-system.googlecode.com/svn/html/Conduit/igmp_std.png

|| Status || Description ||
|| NonMember || Not belonging to the group. ||
|| DelayingMember || Checking whether it belongs to the group or not. ||
|| IdleMember || Belonging to the group. ||

N.B. There are several versions of IGMP and if a QUERY version that is older than the default node version is received from the router, the version of IGMP that uses the node needs to be dynamically lowered, however in ES only IGMPv2 is currently implemented.

Please refer to igmp.cpp and RFC 2236.

== Inet4Address object ==

An Inet4Address object is one that keeps information attached to an IP address. A new Inet4Address object can be created by calling the IResolver interface's getHostByAddress and getHostByName methods.

----

== References ==

`[`Comer 87`]` D. Comer, "Operating System Design - Volume II: Internetworking with Xinu," Prentice-Hall, 1986.

`[`Hüni 95`]` H. Hüni, R. E. Johnson, R. Engel, "A Framework for Network Protocol Software," In ''Proc. OOPSLA '95, SIGPLAN Notices'', pp. 358-369, Oct. 1995.

`[`Nikander 98`]` P. Nikander, et al., "Java Conduits Beans (Jacob) project," http://www.tml.tkk.fi/Research/TeSSA/Old_pages/Jacob/jacob3.html.

`[`Pike 84`]` R. Pike, "The Blit: A Multiplexed Graphics Terminal," AT&T Bell Laboratories Technical Journal, Vol 63, No. 8, Part 2, pp. 1607-1632, Oct. 1984.

`[`Ritchie 84`]` D. M. Ritchie, "A Stream Input Output System," AT&T Bell Laboratories Technical Journal, Vol 63, No. 8, Part 2, pp. 1897-1910, Oct. 1984.

`[`Wright 95`]` G. R. Wright, W. R. Stevens, "TCP/IP Illustrated, Volume 2:The Implementation", Addison-Wesley, 1995.